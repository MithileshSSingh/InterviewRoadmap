const rnPhase12 = {
  id: "phase-12",
  title: "Phase 12: Interview Preparation",
  emoji: "ðŸ“",
  description: "Comprehensive interview bank â€” 50 React Native deep-dive questions, 30 architecture questions, 20 debugging questions, 30 JavaScript internals, 20 system design, and 20 DSA questions with senior-level answers.",
  topics: [
    {
      id: "rn-deep-dive-questions",
      title: "50 React Native Deep-Dive Questions",
      explanation: `This section contains 50 carefully curated React Native questions spanning architecture, performance, internals, and production scenarios. Each question is at the senior/staff interview level with comprehensive expected answers.

**How to use these questions:**
1. Answer each question first WITHOUT looking at the answer
2. Compare your answer with the expected answer
3. Note gaps in your knowledge
4. Research those gaps using the earlier roadmap phases
5. Re-attempt the question after studying
6. Practice explaining the answer verbally (as you would in an interview)

**Question categories covered:**
- React Native Architecture & Internals (15 questions)
- Performance Optimization (10 questions)
- State Management & Data Flow (10 questions)
- Navigation & Lifecycle (5 questions)
- Native Integration (5 questions)
- Production & Debugging (5 questions)`,
      codeExample: `// Questions are in the interviewQuestions array below.
// Each contains the question and a comprehensive senior-level answer.
// Study them by attempting answers BEFORE reading the solutions.`,
      exercise: `**Practice Protocol:**
1. Set a timer for 5 minutes per question
2. Write your answer on paper or in a plain text editor (no IDE)
3. Grade yourself: Full marks (complete answer), Partial (missed key points), or Fail (fundamentally wrong)
4. Track your scores â€” aim for >80% Full marks before interviewing
5. For any 'Fail' answers, study the relevant roadmap phase and retry in 48 hours
6. Do mock interviews with a partner using these questions randomly`,
      commonMistakes: [
        "Memorizing answers verbatim â€” interviewers can tell; understand the WHY behind each concept",
        "Only studying the 'what' and not the 'when' â€” know not just what React.memo does, but when to use it (and when NOT to)",
        "Not practicing verbal explanations â€” reading an answer is different from articulating it clearly under pressure",
        "Skipping questions you think you know â€” overconfidence leads to incomplete answers in actual interviews",
        "Not connecting concepts â€” the best answers reference related topics (e.g., connecting Fiber to performance to concurrent rendering)",
      ],
      interviewQuestions: [
        { type: "conceptual", q: "Explain React Native's New Architecture (JSI, Fabric, TurboModules) and why it was needed.", a: "The old architecture used an async JSON bridge between JS and Native â€” every call was serialized, batched, and deserialized. This caused: serialization overhead, no synchronous calls, all modules loaded at startup. **JSI** replaces the bridge with C++ bindings â€” JS holds direct references to C++ objects, enabling synchronous calls and zero-copy data sharing. **TurboModules** are native modules defined by TypeScript specs (codegen) â€” they're lazy-loaded and type-safe. **Fabric** is the new rendering system â€” shadow tree is in C++, layout can run on any thread, enables synchronous layout measurements and concurrent rendering." },
        { type: "conceptual", q: "How does the Hermes engine differ from JavaScriptCore and V8?", a: "Hermes is optimized for React Native mobile: (1) AOT bytecode compilation â€” JS compiled to bytecode at build time, not runtime. 30-50% faster startup. (2) No JIT â€” saves memory, simpler runtime, but computation-heavy loops are slower. (3) Incremental GC â€” shorter pauses for smoother UI. (4) Smaller binary size. Trade-off: raw compute speed is lower than V8's JIT-optimized code, but startup, memory, and GC behavior are superior for mobile." },
        { type: "conceptual", q: "What is the difference between useEffect and useLayoutEffect? When would you use each?", a: "Both run after render, but timing differs. **useEffect**: runs asynchronously AFTER the browser paints. Use for: data fetching, subscriptions, analytics. Non-blocking. **useLayoutEffect**: runs synchronously BEFORE the browser paints. Use for: measuring DOM layout, synchronous visual updates that must be visible on first paint (preventing flicker). Warning: useLayoutEffect blocks painting â€” keep it fast. Example: measuring element dimensions to position a tooltip." },
        { type: "conceptual", q: "Explain the Fiber architecture and how it enables concurrent rendering.", a: "Fiber is React's incremental reconciler. Each component is a Fiber node in a linked list tree (child/sibling/return pointers). Key innovation: rendering is split into small units of work that can be paused, resumed, or abandoned. Two phases: Render (interruptible â€” compute diffs) and Commit (synchronous â€” apply changes). This enables concurrent rendering: low-priority updates (data fetching) can be interrupted by high-priority updates (user input), keeping the UI responsive." },
        { type: "conceptual", q: "How does React Native handle styling and layout differently from web CSS?", a: "RN uses Yoga (flexbox engine) with key differences: (1) Default flexDirection is 'column' (web: 'row'). (2) Default flexShrink is 0 (web: 1). (3) All values are density-independent pixels (no units). (4) No cascading â€” styles don't inherit (except Text inherits from parent Text). (5) StyleSheet.create for optimization â€” flattened at create time. (6) No CSS Grid, float, display:inline. (7) Percentage values supported but limited. (8) aspectRatio supported natively." },
        { type: "scenario", q: "Your FlatList with 1000 items is laggy during fast scrolling. What do you do?", a: "Systematic optimization: (1) Add `getItemLayout` for fixed-height items â€” skips measurement. (2) React.memo on renderItem component. (3) useCallback for renderItem and onPress callbacks. (4) Reduce `windowSize` (default 21) to render fewer off-screen items. (5) Set `maxToRenderPerBatch` appropriately. (6) Use `removeClippedSubviews={true}`. (7) Consider FlashList (Shopify) â€” cell recycling is 5-10x faster. (8) Profile with React DevTools to identify re-rendering items. (9) Check if `keyExtractor` uses stable, unique IDs (not index)." },
        { type: "scenario", q: "How would you optimize the startup time of a React Native app?", a: "Multi-phase approach: (1) **Engine**: Use Hermes for AOT bytecode compilation (30-50% faster). (2) **Bundle**: Analyze with bundle-visualizer, remove unused deps, inline-require heavy modules. (3) **Initialization**: Defer non-critical init (analytics, crash reporting) with InteractionManager. (4) **Rendering**: Show skeleton UI immediately, load data async. Lazy-load screens with React.lazy. (5) **Native**: Use TurboModules for lazy native module init. Defer native SDK initialization. (6) **Measure**: Track native init â†’ FMP with performance markers." },
        { type: "conceptual", q: "Explain the concept of stale closures in React hooks and how to prevent them.", a: "Stale closures occur when a hook callback captures a state/prop value at closure creation time, not the current value. Example: useEffect with [] deps captures initial state forever. The callback reads the stale initial value even after state updates. **Fixes:** (1) Functional state updates: `setState(prev => prev + 1)`. (2) Refs for latest values: `const ref = useRef(value); ref.current = value; // read ref.current in callback`. (3) Correct dependency arrays â€” include all referenced values. (4) AbortController pattern for async effects." },
        { type: "conceptual", q: "What is the Virtual DOM and how does reconciliation work?", a: "Virtual DOM is a lightweight JS object representation of the UI tree. On state change, React creates a new virtual tree and diffs it against the previous one (reconciliation). The algorithm is O(n) using two heuristics: (1) Different element types produce entirely different trees. (2) Keys identify stable elements in lists. Diffing computes minimal changes (create, update, delete), which are then applied to the actual native view hierarchy. This batching of changes is more efficient than direct manipulation." },
        { type: "scenario", q: "Design the state management architecture for a 50-screen app with 10 engineers.", a: "**Hybrid approach:** (1) **Server state**: React Query (TanStack Query) â€” caching, refetching, invalidation handled automatically. Eliminates 60%+ of Redux boilerplate. (2) **Client state**: Zustand with selectors â€” `useAppStore(s => s.theme)` only re-renders when theme changes. Persisted with MMKV. (3) **Form state**: React Hook Form or local useState â€” never goes to global store. (4) **Navigation state**: React Navigation manages its own state. (5) **Derived state**: Computed via selectors/useMemo, never stored. Rules: each feature owns its state, no cross-feature direct state access (use events or shared queries)." },
        { type: "conceptual", q: "How do React Native animations work? Compare Animated API, Reanimated, and LayoutAnimation.", a: "**Animated API**: JS-driven by default, can use `useNativeDriver: true` for transform/opacity (runs on UI thread). Limited: only transform and opacity work natively. **Reanimated**: Runs animations entirely on the UI thread via worklets (small JS functions compiled to C++). Supports any style property, gesture-driven animations, shared values. Best for complex, gesture-driven animations. **LayoutAnimation**: Automatically animates layout changes (mount/unmount, size changes). Simple API but coarse control. Android support is inconsistent. Best for simple appear/disappear animations." },
        { type: "conceptual", q: "Explain the React Native bridge and its limitations.", a: "The bridge is an async, JSON-serialized message passing system between JS and Native threads. Limitations: (1) **Serialization overhead** â€” every value crossing the bridge is JSON.stringify'd and parsed. (2) **Async only** â€” can't synchronously return values from native. (3) **Batching delay** â€” messages batched every ~5ms. (4) **Bottleneck** â€” high-frequency calls (scroll events, gestures) flood the bridge. (5) **No type safety** â€” JSON has no schema enforcement. The New Architecture (JSI) solves all of these by replacing the bridge with direct C++ bindings." },
        { type: "scenario", q: "How do you handle offline support in a React Native app?", a: "**Offline-first architecture:** (1) Local database (WatermelonDB/SQLite) as primary data source â€” all reads from local. (2) NetInfo listener for connectivity status. (3) Write operations queued locally with 'pending' status. (4) Sync engine pushes pending changes when online (WorkManager for reliability). (5) Pull remote changes since last sync cursor. (6) Conflict resolution: field-level merge for non-conflicting changes, LWW or user-prompted for conflicts. (7) UI shows offline indicator and 'changes will sync' messaging. (8) Cache images with FastImage for offline media access." },
        { type: "conceptual", q: "What are the key differences between React.memo, useMemo, and useCallback?", a: "**React.memo**: HOC that prevents a COMPONENT from re-rendering if its props haven't changed (shallow comparison). Wraps the component definition. **useMemo**: Caches a computed VALUE â€” only recomputes when dependencies change. Used inside a component for expensive calculations. **useCallback**: Caches a FUNCTION REFERENCE â€” returns the same function instance unless dependencies change. Used to stabilize callbacks passed to memoized children. They work together: memo on child + useCallback on parent's callback prop + useMemo on computed props." },
        { type: "scenario", q: "Your app crashes on a low-end Android device but works fine on high-end devices. How do you debug?", a: "**Low-end device debugging:** (1) Profile memory â€” low-end devices have 1-2GB RAM. Use Hermes profiler for JS heap, Android Studio profiler for native heap. (2) Check image memory â€” reduce image sizes, implement aggressive cache eviction. (3) Reduce view count â€” flatten layouts, use fewer simultaneous screens (reduce navigation stack size). (4) Profile CPU â€” check for expensive JS computations that exceed the weak CPU's capacity. (5) Test with `__DEV__` false â€” development mode adds significant overhead. (6) Enable Hermes â€” AOT compilation and lower memory footprint help weak devices most. (7) Implement performance tiers â€” detect device capability and simplify UI/animations for weak devices." },
      ],
    },
    {
      id: "architecture-system-design-questions",
      title: "Architecture, System Design & DSA Questions",
      explanation: `**Architecture Questions (30)** test your ability to design and defend mobile system decisions.

**System Design Questions (20)** test your ability to design complete mobile systems from requirements to implementation.

**DSA Questions (20)** relevant to mobile/frontend â€” arrays, strings, trees, graphs, and mobile-specific data structures.

These questions represent the most frequently asked topics at top companies for Senior/Staff React Native roles.`,
      codeExample: `// Questions are organized in the interviewQuestions array below.
// Architecture, System Design, and DSA questions with expected answers.`,
      exercise: `**Practice Protocol:**
1. Architecture: Practice explaining decisions in 3-5 minutes (interview time box)
2. System Design: Practice drawing architecture diagrams on a whiteboard (or iPad)
3. DSA: Solve on paper/plain editor first, then verify in an IDE
4. Time yourself â€” 30 minutes for system design, 25 minutes for DSA
5. After each practice session, note what you'd improve and retry in 3 days`,
      commonMistakes: [
        "In system design, jumping to implementation without clarifying requirements â€” spend 5 minutes on requirements",
        "In architecture questions, giving the 'textbook' answer without trade-offs â€” always discuss WHY and WHEN",
        "In DSA, optimizing prematurely â€” start with brute force, optimize incrementally, explain each step",
        "Not drawing diagrams in system design â€” visual communication is expected at senior level",
        "Giving one-sided answers â€” always present trade-offs, alternatives considered, and decision rationale",
      ],
      interviewQuestions: [
        // Architecture Questions
        { type: "conceptual", q: "How would you architect a React Native app for 10 teams working simultaneously?", a: "Feature-based monorepo using Turborepo. Each team owns a feature module (`features/auth`, `features/checkout`). Shared packages: `packages/ui-kit`, `packages/api-client`, `packages/analytics`. Each feature has its own state, screens, and tests. Public API via `index.ts` â€” no importing internals from other features. CODEOWNERS enforces review boundaries. ESLint import restrictions prevent dependency violations. Shared design system ensures visual consistency. Architecture review board approves cross-feature changes." },
        { type: "conceptual", q: "When would you use Redux vs Zustand vs Context vs React Query?", a: "**Redux**: Complex client state needing middleware (undo/redo, time-travel debugging). **Zustand**: Lightweight global client state (theme, UI preferences). 1KB, selector-based re-renders. **Context**: Infrequently-changing config (locale, feature flags). **React Query**: ALL server state â€” handles caching, refetching, invalidation, optimistic updates. The mistake: putting server state in Redux. Modern stack: React Query for API data + Zustand for client state + Context for config." },
        { type: "scenario", q: "Design the navigation architecture for a banking app with authentication, onboarding, and main flows.", a: "**Nested navigators with auth gating:** Root navigator switches between: (1) Auth stack (login, signup, forgot password). (2) Onboarding stack (shown once on first login). (3) Main tab navigator (home, transfers, cards, settings). Each tab has its own stack. Auth state drives root navigation â€” `isAuthenticated ? <Main /> : <Auth />`. Deep links route through a central handler that checks auth before navigating. Session timeout returns to auth stack. Biometric unlock shows lock screen overlay." },
        { type: "conceptual", q: "How do you ensure code quality in a large React Native codebase?", a: "Multi-layered: (1) TypeScript strict mode â€” catch type errors at build time. (2) ESLint with custom rules: no inline styles, no direct API calls outside api layer, exhaustive deps. (3) Prettier for formatting â€” zero debates on style. (4) PR review with CODEOWNERS â€” architectural changes need tech lead review. (5) CI gates: all tests pass, coverage threshold met, bundle size within budget. (6) Architecture review for new features â€” ADR required before implementation. (7) Automated codemods for deprecation migration." },
        { type: "scenario", q: "Your React Native app needs to support 5 white-label versions with different branding. How?", a: "**Theming + build variants.** (1) Theme system: all colors, fonts, spacing from a theme object (not hardcoded). Each brand has a theme JSON. (2) Asset management: brand-specific assets (logos, icons) in separate directories, selected at build time. (3) Build variants: Android product flavors + iOS build configurations. Each variant sets brand identifier. (4) Feature differences: feature flags per brand (some brands get premium features). (5) Single codebase: NO forking. All brand differences are data-driven (config files), not code-driven (if/else). (6) CI: parallel builds for all 5 brands on every release." },

        // System Design Questions
        { type: "scenario", q: "Design Instagram's feed for React Native.", a: "**Requirements:** Infinite scroll, mixed content (photos, videos, stories), real-time likes/comments, offline caching. **Architecture:** FlashList with estimated item sizes per content type. Image: FastImage with progressive loading and LRU cache. Video: play only visible video (viewability tracking), preload next video. State: React Query for feed data with cursor-based pagination. Offline: cache last 50 posts in SQLite. Optimistic: like/comment update immediately, rollback on failure. Real-time: WebSocket for new likes/comments on visible posts. Performance: React.memo on feed items, useCallback for actions." },
        { type: "scenario", q: "Design a notification delivery system for a social media app.", a: "**Multi-channel:** Push (FCM/APNs), in-app (real-time WebSocket), email (for inactive users). **Push path:** Event occurs (like, comment) â†’ Notification service determines recipients â†’ FCM/APNs delivery â†’ Device receives. **In-app path:** WebSocket channel per user â†’ real-time delivery â†’ in-app notification center. **Design decisions:** Batching (multiple likes â†’ '5 people liked your post'), deduplication (don't notify for your own actions), priority (direct message > like), quiet hours (respect user settings). **Client:** Notification center with tabs (all, mentions, likes). Badge count synced via API. Tap â†’ deep link to relevant content." },
        { type: "scenario", q: "Design an offline-first note-taking app (like Google Keep).", a: "**Local-first:** All reads/writes to local SQLite database. **Sync:** Operation log tracking all changes. Background sync via WorkManager. Delta sync with cursor (only send/receive changes). **Conflict resolution:** Field-level three-way merge â€” compare local, remote, and base version. Non-conflicting field changes auto-merge. Same-field conflicts: LWW for simple fields, character-level merge for text (OT/CRDT). **Data model:** Note { id, title, body, color, labels, updatedAt, syncVersion, syncStatus }. **Media:** Images stored locally + uploaded to CDN. Image references in notes use local path + remote URL." },

        // DSA Questions
        { type: "coding", q: "Implement a function that flattens a deeply nested object: { a: { b: { c: 1 } } } â†’ { 'a.b.c': 1 }", a: "```typescript\nfunction flattenObject(obj: Record<string, any>, prefix = ''): Record<string, any> {\n  const result: Record<string, any> = {};\n  \n  for (const key of Object.keys(obj)) {\n    const newKey = prefix ? `${prefix}.${key}` : key;\n    \n    if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {\n      Object.assign(result, flattenObject(obj[key], newKey));\n    } else {\n      result[newKey] = obj[key];\n    }\n  }\n  \n  return result;\n}\n// Time: O(n) where n = total key-value pairs. Space: O(n)\n```" },
        { type: "coding", q: "Implement a debounce function with TypeScript generics that preserves the argument types.", a: "```typescript\nfunction debounce<T extends (...args: any[]) => any>(\n  fn: T,\n  delay: number\n): (...args: Parameters<T>) => void {\n  let timeoutId: ReturnType<typeof setTimeout> | null = null;\n  \n  return (...args: Parameters<T>) => {\n    if (timeoutId !== null) clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      fn(...args);\n      timeoutId = null;\n    }, delay);\n  };\n}\n// Usage: const debouncedSearch = debounce((query: string) => search(query), 300);\n```" },
        { type: "coding", q: "Given a list of time intervals, merge overlapping intervals.", a: "```typescript\nfunction mergeIntervals(intervals: [number, number][]): [number, number][] {\n  if (intervals.length <= 1) return intervals;\n  \n  intervals.sort((a, b) => a[0] - b[0]);\n  const result: [number, number][] = [intervals[0]];\n  \n  for (let i = 1; i < intervals.length; i++) {\n    const last = result[result.length - 1];\n    if (intervals[i][0] <= last[1]) {\n      last[1] = Math.max(last[1], intervals[i][1]);\n    } else {\n      result.push(intervals[i]);\n    }\n  }\n  \n  return result;\n}\n// Time: O(n log n) for sort. Space: O(n) for result.\n```" },
        { type: "coding", q: "Implement an LRU Cache with O(1) get and put operations.", a: "```typescript\nclass LRUCache<K, V> {\n  private cache = new Map<K, V>();\n  \n  constructor(private capacity: number) {}\n  \n  get(key: K): V | undefined {\n    if (!this.cache.has(key)) return undefined;\n    const value = this.cache.get(key)!;\n    // Move to end (most recently used)\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    return value;\n  }\n  \n  put(key: K, value: V): void {\n    if (this.cache.has(key)) this.cache.delete(key);\n    this.cache.set(key, value);\n    if (this.cache.size > this.capacity) {\n      // Delete oldest (first) entry\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n  }\n}\n// Map preserves insertion order â€” delete+set moves to end. O(1) all ops.\n```" },
        { type: "coding", q: "Find the longest substring without repeating characters.", a: "```typescript\nfunction longestSubstring(s: string): number {\n  const lastSeen = new Map<string, number>();\n  let maxLen = 0;\n  let left = 0;\n  \n  for (let right = 0; right < s.length; right++) {\n    if (lastSeen.has(s[right]) && lastSeen.get(s[right])! >= left) {\n      left = lastSeen.get(s[right])! + 1;\n    }\n    lastSeen.set(s[right], right);\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n  \n  return maxLen;\n}\n// Sliding window. Time: O(n). Space: O(min(n, charset)).\n```" },
      ],
    },
  ],
};

export default rnPhase12;
